// src/AnimatedGlowWrapper.js

import React, { useEffect, useMemo, useState } from 'react';
import { View, StyleSheet, LayoutChangeEvent, Platform } from 'react-native';
import Svg, { Path, Defs, RadialGradient, Stop } from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withRepeat,
  withTiming,
  Easing,
  useFrameCallback,
} from 'react-native-reanimated';
import PropTypes from 'prop-types';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedRadialGradient = Animated.createAnimatedComponent(RadialGradient);

const OrbGradient = ({ orb, id, size, colors }) => {
  const animatedProps = useAnimatedProps(() => ({
    r: (size / 2) * orb.scale.value,
  }));

  const gradientId = `${id}-grad`;

  return (
    <>
      <Defs>
        <AnimatedRadialGradient
          id={gradientId}
          cx={orb.x}
          cy={orb.y}
          rx={size / 2}
          ry={size / 2}
          fx={orb.x}
          fy={orb.y}
          animatedProps={animatedProps}
        >
          {colors.map((color, index) => (
            <Stop
              key={index}
              offset={`${(index / (colors.length - 1)) * 100}%`}
              stopColor={color}
              stopOpacity={index === colors.length - 1 ? 0 : 1}
            />
          ))}
        </AnimatedRadialGradient>
      </Defs>
      <AnimatedPath d={orb.path} fill={`url(#${gradientId})`} />
    </>
  );
};

const useGlowPath = (cornerRadius, width, height) => {
  return useMemo(() => {
    if (width === 0 || height === 0) return '';
    const r = Math.min(cornerRadius, width / 2, height / 2);
    return `M${r},0 H${width - r} A${r},${r} 0 0 1 ${width},${r} V${height - r} A${r},${r} 0 0 1 ${width - r},${height} H${r} A${r},${r} 0 0 1 0,${height - r} V${r} A${r},${r} 0 0 1 ${r},0 Z`;
  }, [width, height, cornerRadius]);
};

const createOrbs = (numOrbs, path) => {
  return useMemo(() =>
    Array.from({ length: numOrbs }).map(() => ({
      x: useSharedValue(0),
      y: useSharedValue(0),
      scale: useSharedValue(1),
      path: path,
    })), [numOrbs, path]);
};

const getPointAtLength = (length, width, height) => {
  const perimeter = 2 * (width + height);
  let l = length % perimeter;
  if (l < 0) l += perimeter;

  if (l < width) return { x: l, y: 0 };
  l -= width;
  if (l < height) return { x: width, y: l };
  l -= height;
  if (l < width) return { x: width - l, y: height };
  l -= width;
  return { x: 0, y: height - l };
};

const useOrbAnimation = (time, orbs, width, height, speedMultiplier, randomness, scaleAmplitude, scaleFrequency) => {
  const pathLength = useMemo(() => 2 * (width + height), [width, height]);

  useFrameCallback(() => {
    if (pathLength === 0 || orbs.length === 0) return;

    orbs.forEach((orb, i) => {
      const progress = (time.value * speedMultiplier + i * (1 / orbs.length)) % 1;
      const point = getPointAtLength(progress * pathLength, width, height);
      
      orb.x.value = point.x + (Math.random() - 0.5) * width * randomness;
      orb.y.value = point.y + (Math.random() - 0.5) * height * randomness;

      if (scaleAmplitude > 0) {
        orb.scale.value = 1 + scaleAmplitude * Math.sin(time.value * 2 * Math.PI * scaleFrequency + i);
      }
    });
  }, true);
};

const AnimatedGlowWrapper = ({ children, style, preset: presetObject = {}, ...overrideProps }) => {
  const defaultProps = {
    cornerRadius: 10, outlineWidth: 2, borderColor: 'white', animationSpeed: 0.7, randomness: 0.01,
    outerGlowColors: ['#00FFFF', '#FF00FF', '#FFFF00'], outerGlowOpacity: 0.15, outerGlowDotSize: 100, outerGlowNumberOfOrbs: 20, outerGlowInset: 15, outerGlowSpeedMultiplier: 1.0, outerGlowScaleAmplitude: 0, outerGlowScaleFrequency: 2.5,
    innerGlowColors: ['#00FFFF', '#FF00FF', '#FFFF00'], innerGlowOpacity: 0.3, innerGlowDotSize: 50, innerGlowNumberOfOrbs: 20, innerGlowInset: 15, innerGlowSpeedMultiplier: 1.0, innerGlowScaleAmplitude: 0, innerGlowScaleFrequency: 2.5,
  };

  const config = useMemo(() => ({
    ...defaultProps, ...presetObject, ...overrideProps,
  }), [presetObject, overrideProps]);

  const [layout, setLayout] = useState({ width: 0, height: 0 });
  const time = useSharedValue(0);

  useEffect(() => {
    const duration = config.animationSpeed === 0 ? Infinity : 10000 / config.animationSpeed;
    if (duration !== Infinity) {
      time.value = withRepeat(withTiming(1, { duration, easing: Easing.linear }), -1, false);
    }
  }, [config.animationSpeed, time]);

  const mainPathD = useGlowPath(config.cornerRadius, layout.width, layout.height);
  const innerPathD = useGlowPath(config.cornerRadius - config.innerGlowInset, layout.width - config.innerGlowInset * 2, layout.height - config.innerGlowInset * 2);
  const outerPathD = useGlowPath(config.cornerRadius - config.outerGlowInset, layout.width - config.outerGlowInset * 2, layout.height - config.outerGlowInset * 2);

  const outerOrbs = createOrbs(config.outerGlowNumberOfOrbs, outerPathD);
  const innerOrbs = createOrbs(config.innerGlowNumberOfOrbs, innerPathD);

  useOrbAnimation(time, outerOrbs, layout.width - config.outerGlowInset * 2, layout.height - config.outerGlowInset * 2, config.outerGlowSpeedMultiplier, config.randomness, config.outerGlowScaleAmplitude, config.outerGlowScaleFrequency);
  useOrbAnimation(time, innerOrbs, layout.width - config.innerGlowInset * 2, layout.height - config.innerGlowInset * 2, config.innerGlowSpeedMultiplier, config.randomness, config.innerGlowScaleAmplitude, config.innerGlowScaleFrequency);

  const onLayout = (event) => setLayout(event.nativeEvent.layout);

  return (
    <View style={style} onLayout={onLayout}>
      {layout.width > 0 && layout.height > 0 && (
        <View style={StyleSheet.absoluteFill} pointerEvents="none">
          <Svg width={layout.width} height={layout.height}>
            <Defs>
                <Path id="mainClipPath" d={mainPathD} />
            </Defs>
            <View style={{ opacity: config.outerGlowOpacity, transform: [{ translateX: config.outerGlowInset, translateY: config.outerGlowInset }] }}>
              {outerOrbs.map((orb, i) => (
                <OrbGradient key={`outer-orb-${i}`} orb={orb} id={`outer-orb-${i}`} size={config.outerGlowDotSize} colors={config.outerGlowColors} />
              ))}
            </View>
            <View style={{ opacity: config.innerGlowOpacity, transform: [{ translateX: config.innerGlowInset, translateY: config.innerGlowInset }] }}>
              {innerOrbs.map((orb, i) => (
                <OrbGradient key={`inner-orb-${i}`} orb={orb} id={`inner-orb-${i}`} size={config.innerGlowDotSize} colors={config.innerGlowColors} />
              ))}
            </View>
          </Svg>
        </View>
      )}

      <View style={{
        borderWidth: config.outlineWidth,
        borderColor: config.borderColor,
        borderRadius: config.cornerRadius,
        overflow: 'hidden'
      }}>
        {children}
      </View>
    </View>
  );
};

AnimatedGlowWrapper.propTypes = {
  preset: PropTypes.object,
  children: PropTypes.node.isRequired,
  style: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
  cornerRadius: PropTypes.number,
  outlineWidth: PropTypes.number,
  borderColor: PropTypes.string,
  animationSpeed: PropTypes.number,
  randomness: PropTypes.number,
  outerGlowColors: PropTypes.arrayOf(PropTypes.string),
  outerGlowOpacity: PropTypes.number,
  outerGlowDotSize: PropTypes.number,
  outerGlowNumberOfOrbs: PropTypes.number,
  outerGlowInset: PropTypes.number,
  outerGlowSpeedMultiplier: PropTypes.number,
  outerGlowScaleAmplitude: PropTypes.number,
  outerGlowScaleFrequency: PropTypes.number,
  innerGlowColors: PropTypes.arrayOf(PropTypes.string),
  innerGlowOpacity: PropTypes.number,
  innerGlowDotSize: PropTypes.number,
  innerGlowNumberOfOrbs: PropTypes.number,
  innerGlowInset: PropTypes.number,
  innerGlowSpeedMultiplier: PropTypes.number,
  innerGlowScaleAmplitude: PropTypes.number,
  innerGlowScaleFrequency: PropTypes.number,
};

export default AnimatedGlowWrapper;